---
description: Objective
globs: *.js
---
# Yoep-de-LEDLights Processor - Project Overview

## Objective
This tool is designed to downsize Yoep de Light profiles for racing simulators, specifically to adjust LED segment configurations for different car models.

## Core Functionality
- Modifies JSON profile files to adjust LED segment counts for left, middle, and right modules
- Reconfigures start positions for LED segments based on user specifications
- Preserves complex car-specific LED behavior while adapting to different hardware configurations

## Key Components
1. **Path-based JSON manipulation system** - Uses a sophisticated path-based approach to locate and modify nested JSON structures
2. **Car-specific handlers** - Each car model has a dedicated handler function (e.g., `fiaF4`) that knows how to adjust that car's specific LED configuration
3. **Segment counting utilities** - Helper functions like `countSegmentValues` calculate total LED segments from configuration strings

## Approach for Adding New Car Support
When adding support for a new car model (like the Mercedes W12):

1. **Study the car's LED configuration** - Examine the JSON structure to understand how LEDs are organized (see the reference comments in the car file)

2. **Implement the handler function** - Create a function that:
   - Takes `startPosition` and `numberOfSegments` parameters
   - Returns a function that transforms the car's configuration
   - Adjusts `StartPosition` values based on the new segment layout
   - Preserves the car's unique LED behavior (colors, RPM thresholds, etc.)

3. **Handle nested containers** - Many cars have complex nested structures with conditional groups that need careful traversal

4. **Validate segment counts** - Use `countSegmentValues` to verify segment counts match expectations

5. **Add path to paths.js** - Register the car's path in the paths configuration for easy access

6. **Update main.js** - Add the car handler to the processing pipeline

## Important Considerations
- Maintain proper LED alignment by calculating correct start positions
- Preserve car-specific behavior while only changing positioning and segment counts
- Handle both simple RPM segments and complex nested conditional groups
- Ensure error handling for unexpected configurations
- Test thoroughly with the specific car model